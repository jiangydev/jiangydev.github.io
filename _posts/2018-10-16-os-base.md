---
layout:     post
title:      "操作系统 相关问题"
subtitle:   "CPU 调度机制等"
date:       2018-10-16
author:     "jiangydev"
header-img: "img/post-bg-cloud.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 操作系统
---

[TOC]

## 操作系统 相关问题

### 1 CPU 调度机制

#### 1.1 FCFS(先到先服务调度，FIFO)

调度的顺序就是任务到达的顺序，公平、简单、无抢占、不适合交互式，并且没有考虑任务特性，平均等待时间可以缩短。 

#### 1.2 SJF(最短作业优先调度)

最短的作业（占用CPU时间最短的任务）先执行，可以保证最短的平均等待时间。

当任务存在先后顺序，SRJF（SJF的可抢占版本）此时使用该可抢占的方式在平均等待时间上占有优势。

SJF调度经常用于长期调度。对于批处理系统的长期（作业）调度，可以将用户提交作业时间所制定的进程时间极限作为长度。`SJF算法的真正困难`是如何知道下一个CPU区间的长度：可以通过最近信息和历史信息对下一个CPU时间进行预测。

**缺点**：任务优先级太低可能永远得不到执行（饥饿，可以使用优先级动态调整，如任务优先级随着等待时间增大）  

#### 1.3 优先级调度

SJF 可以看作是优先级调度的一个例子，每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS顺序调度。优先级调度算法的一个重要问题是阻塞或饥饿。可以运行但缺乏CPU的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个有低优先级无穷等待CPU。

#### 1.4 RR(轮转调度)

根据先来先服务的原则，将需要执行的所有进程按照到达时间的大小排成一个序列，每次都给一个进程同样大小的时间片，在这个时间片内如果进程执行结束了，那么把进程从进程队列中删去，如果进程没有结束，那么把该进程停止然后改为等待状态，放到进程队列的尾部，直到所有的进程都已执行完毕 。

**优点**：定时有响应，等待时间较短；

**缺点**：上下文切换次数较多；

RR中时间片长度的设定：时间片太大太小都不合适，太大响应时间过长，太小导致吞吐量变小，等待时间过长（上下文切换代价过高）

#### 1.5 多级队列调度

混合了多种调度算法：按照一定规则创建多个进程队列，不同的队列具有不同的优先级而且高优先级的具有抢占权，不同的队列中的任务可以有不同的时间片并且采用不同的调度算法。

**缺点**：没法区分IO约束和CPU约束，同时也存在一定的饥饿现象 

#### 1.6 多级反馈队列调度

任务可以在多个队列中移动，更加细致地区分任务，n可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”，可近似SJF，可使I/Obound停留在高优先级。 